5.22一面，总共时长125min
1.如何保护用户的隐私
2.int* createArray() {int arr[3] = {1, 2, 3}; return arr;} 这段代码有什么问题
3.对上述代码进行改进，写出能想到的所有方法（我写了一个malloc，全局数组，静态数组）
4.说一下三种方式的优缺点
5.全局数组和静态数组有什么区别
6.解释完美转发的作用及实现方式
7.const int*,int const*,int* const, const int* const的区别
8.实现一个无锁计数器
9.调用C++11实现一个线程安全的有界环形队列（circular buffer），要求如下：支持多线程环境下的并发push和pop操作，队列有固定容量，满时push操作要阻塞，空时pop操作要阻塞。不允许使用第三方库，只能用C++11标准库，说明你的实现如何保证线程安全，并分析可能的性能瓶颈。
10.unique_lock 和 lock_guard的区别,为什么你刚才给我的代码用的是unique_lock 而不是 lock_guard 呢
11.你写的代码的性能瓶颈是什么？如果有大量得到生产者和消费者会怎样呢
12.把第9个改成非阻塞的，写一下，为什么你这个非阻塞用lock_guard这个锁呢
13.有一类二叉树用三叉链表来存储的时候除了带有指向左右孩子节点的两个指针,还有指向父节点的指针,那么这样一棵二叉树有n个节点,那么有多少指针指向NULL(对于不存在的节点表示为空)
14.int n = 2019; int count = 0; while(n){count++; n = n&(n - 1);} cout << count << endl;输出是多少，为什么
15.给定一个递增循环整数数组，从里面找出最小的元素，使用的算法越快越好。特别地,最小的元素可能出现在数组中间。比如:50,52,63,90,3,8,15,44,49，int findmin(int array[]){}
16.在二叉排序树上面找出第3大的节点。注意:不能把二叉树全量存储到另外的存储空间，比如存储到数组中，然后取出数组的第三个元素。
class TreeNode {
public:
int value;TreeNode*left;TreeNode* right}；
TreeNode* find(TreeNode*root) {}
17.动态规划题：给定一个长度为l的木棍,已知有n个切割点,要求在每个切割点都要切割,注意每次切割的开销为当前木棍的长度，例如一个10米的木棍,切割点为2，4，7。有多种切割方式,其中可以先切2，再切4,再切7,此时开销为10+8+6=24(第1次切木棍为10米,笑2次切木棍为8米,第3次切木棍为6米)，也可以先切4，再切2,再切7，出约著销为10+4+6=20，这时开销更小你的任务是计算切割的最小开销。

作者：许愿offer快来快快来
链接：[](https://www.nowcoder.com/interview/center?entranceType=导航栏)
来源：牛客网